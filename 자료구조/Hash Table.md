- Hash Table
    - 해시는 내부적으로 배열을 사용
    - 데이터 고유의 인덱스로 접근하여 average case가 O(1)
    - 그러나 저장되는 키 값이 불안정한데 이러한 문제를 특정 알고리즘으로 해결
- Hash Function
    - 키마다의 고유 인덱스를 설정하기 위해 Hash function을 사용한다.
    - 이 방법으로 생성된 고유 숫자 값을 hashcode라고 부른다.
    - 키 → (Hash function) → 작은 범위의 숫자
    - 그러나 어설프게 사용하면 중복된 숫자가 나와 하나의 키에 여러 개의 데이터가 존재할 수 있게 되는 것이다. (Collision)
    - 좋은 해시는 키 전체를 참조.
    - Collision이 많을수록 O(n)에 가까워져 성능이 좋지 못하다.
- 충돌 원인
    - 비둘기 집 원리 - 비둘기가 5마리이고 집이 4개뿐이라면 아무리 균등분배해도 한 개의 집에는 비둘기가 두 마리 이상이 들어갈 수 밖에 없다.
    - 생일 패러독스 - 366명의 사람이 모였을때 생일이 겹치는 사람이 최소 2명 이상이 된다는 이론으로 경우의 수를 넘어서는 통계 표본이 존재할때 필연적인 중복 값이 발생한다는 말이다. 23명만 모여도 50프로가 넘고, 57명만 있어도 중복 생일이 99프로가 넘는다.
        - 생일 공격 - 모든 입력을 계산하지 않고도 해시 충돌을 찾는 공격
- 충돌 해결법
    - 개방 주소법(Open address)
        - 충돌 발생 시, 다른 해시를 찾아 해당 자료를 삽입하는 방식
        - Worst Case: 비어있는 해시를 찾지 못하고 제 위치로 돌아오는 경우 O(n)
        - 탐색 방법 3가지
            - 순차 탐색 - 순차적으로 탐색
            - Quadratic probing - 2차 함수 탐색
            - Double Hashing probing - 2차 해시를 통해 새로운 주소 할당 → 더 많은 연산 소모
    - 분리 연결법(Separate Chaining)
        
        ![image](https://user-images.githubusercontent.com/58693617/158063295-9200be91-fd2c-4734-8d20-2b6a34c6b3fc.png)
        
        - 개방 주소법에 비해 빠른 방법 → 해시를 채운 버킷의 밀도가 높을수록 worst case가 많기 때문이다.
        - 분리 연결법은 보조 해시를 통해 Worst case를 줄인다.
        - Java 7에서 위 방식으로 HashMap을 구현
        - 구현 방식 2가지
            - 링크드 리스트: 각 버킷을 연결 리스트로 만들어 Collision이 생기면 bucket의 list에 추가하는 것. 삽입, 삭제가 간단하지만 작은 데이터 삽입 시 오버헤드가 생긴다.
            - 레드 블랙 트리: 링크드 리스트와 비슷한 방식이다. 트리는 메모리 사용량이 많기 때문에 데이터 개수가 적을땐 링크드 리스트를 사용한다.
